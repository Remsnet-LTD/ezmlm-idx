###################################################
# account to receive digests and archive excerpts #
###################################################

if [ "$SECT" = "1" ]; then

#####################
# test ezmlm-reject #
#####################
  prompt "ezmlm-reject:         "
  FROM="$EZTEST"
  TO="$EZTEST-__tstlist@$HOST"
  SUBJECT="test"
  CONTENT="multipart/mixed"
  CC="<>"
  BODY=''

  ${EZBIN}/ezmlm-reject "${DIR}" </dev/null >/dev/null 2>&1 && \
        { ${ECHO} "failed to reject missing \$SENDER"; \
          exit 100; }

  SENDER=''; export SENDER
  ${EZBIN}/ezmlm-reject "${DIR}" </dev/null >/dev/null 2>&1 && \
        { ${ECHO} "failed to reject empty sender"; \
          exit 100; }

  SENDER="${SND}@$HOST"; export SENDER

# with directory
  make_message | ${EZBIN}/ezmlm-reject "${DIR}" || \
	{ ${ECHO} "failed to accept good message with dir"; \
	exit 100; }
# without directory

  make_message | ${EZBIN}/ezmlm-reject || \
	{ ${ECHO} "failed to accept good message without dir: $?"; \
	exit 100; }

#too small
  ${ECHO} "5000:1000" > "${DIR}/msgsize"
  { make_message | ${EZBIN}/ezmlm-reject "${DIR}"; } >/dev/null 2>&1 && \
	{ ${ECHO} "ezmlm-reject failed to reject too small message"; \
		exit 100; }

# just right
  ${ECHO} "500:5" > "${DIR}/msgsize"
  make_message | ${EZBIN}/ezmlm-reject "${DIR}" || \
	{ ${ECHO} "failed to accept message of ok size"; \
	exit 100; }

#too large
  ${ECHO} "20:10" > "${DIR}/msgsize"
  { make_message  | ${EZBIN}/ezmlm-reject "${DIR}"; } > /dev/null 2>&1 && \
        { ${ECHO} "ezmlm-reject failed to reject too large message"; \
                exit 100; }

# restore
  ${RM} -f "${DIR}/msgsize"

# without subject
  SUBJECT=''
   { make_message  | ${EZBIN}/ezmlm-reject "${DIR}"; } > /dev/null 2>&1 && \
        { ${ECHO} "ezmlm-reject failed to reject null subject"; \
                exit 100; }
   { make_message  | ${EZBIN}/ezmlm-reject ; } > /dev/null 2>&1 && \
        { ${ECHO} "ezmlm-reject failed to reject null subject"; \
                exit 100; }		

# with empty subject
  SUBJECT='(NUll)'
   { make_message  | ${EZBIN}/ezmlm-reject "${DIR}"; } > /dev/null 2>&1 && \
        { ${ECHO} "ezmlm-reject failed to reject null subject with dir"; \
                exit 100; }
   { make_message  | ${EZBIN}/ezmlm-reject; } > /dev/null 2>&1 && \
        { ${ECHO} "ezmlm-reject failed to reject null subject without dir"; \
                exit 100; }
# testing -S
  { make_message | ${EZBIN}/ezmlm-reject -S "${DIR}"; } > /dev/null || \
	{ ${ECHO} "-S switch failed with dir"; exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject -S; } > /dev/null || \
	{ ${ECHO} "-S switch failed without dir"; exit 100; }

# with command subject
  SUBJECT='REmOVE'
  { make_message | ${EZBIN}/ezmlm-reject "${DIR}"; } > /dev/null 2>&1 && \
	{ ${ECHO} "failed to reject command subject with dir"; \
		exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject "${DIR}"; } > /dev/null 2>&1 && \
	{ ${ECHO} "failed to reject command subject without dir"; \
		exit 100; }
# testing -C
  { make_message | ${EZBIN}/ezmlm-reject -C "${DIR}"; } > /dev/null || \
	{ ${ECHO} "-C switch failed with dir"; exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject -C;  } > /dev/null || \
	{ ${ECHO} "-C switch failed without dir"; exit 100; }

SUBJECT='test'

# Test with list name in Cc:
  CC="$TO"
  TO="nobody@$HOST"
  { make_message | ${EZBIN}/ezmlm-reject "${DIR}"; } > /dev/null || \
	{ ${ECHO} "failed to accept good Cc: with dir"; \
		exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject; } > /dev/null || \
	{ ${ECHO} "failed to accept good Cc: without dir"; \
		exit 100; }

# Bad To/Cc
  CC="$TO"
  { make_message | ${EZBIN}/ezmlm-reject "${DIR}"; } > /dev/null 2>&1 && \
		{ ${ECHO} "failed to reject bad To/Cc with dir"; \
		exit 100; }
  if [ "$?" != "100" ]; then
	${ECHO} "failed to exit 100 on error"; exit 100
  fi
  { make_message | ${EZBIN}/ezmlm-reject -q "${DIR}"; } > /dev/null 2>&1 && \
		{ ${ECHO} "failed to reject bad To/Cc with dir"; \
		exit 100; }
  if [ "$?" -ne "99" ]; then
	${ECHO} "-q failed"; exit 100
  fi

# for backwards-compatibility and since we don't know inlocal@inhost without
# dir, ezmlm-reject doesn't check To/Cc when there is no dir
  { make_message | ${EZBIN}/ezmlm-reject; } > /dev/null || \
		{ ${ECHO} "failed to accept bad To/Cc without dir"; \
		exit 100; }

# testing -T
  { make_message | ${EZBIN}/ezmlm-reject -T "${DIR}"; } > /dev/null || \
	{ ${ECHO} "-T switch failed with dir"; exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject -T; } > /dev/null || \
	{ ${ECHO} "-T switch failed without dir"; exit 100; }

# restore good TO
  TO="$EZTEST-__tstlist@$HOST"

# if part is mimereject message should be rejected
  touch "${DIR}"/mimeremove
  ${ECHO} "text/html" > "${DIR}"/mimereject
  { make_message | ${EZBIN}/ezmlm-reject "${DIR}"; }  > /dev/null 2>&1 && \
	{ ${ECHO} "mimereject failed with dir"; exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject; } > /dev/null || \
	{ ${ECHO} "mimereject without dir"; exit 100; }

# if part is removed ezmlm-reject should not reject
  ${ECHO} "tExt/htMl" > "${DIR}"/mimeremove
  ${ECHO} "" > "${DIR}"/mimereject 
  { make_message | ${EZBIN}/ezmlm-reject "${DIR}"; } > /dev/null || \
	{ ${ECHO} "mimeremove failed with dir"; exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject; } > /dev/null || \
	{ ${ECHO} "mimeremove without dir"; exit 100; }

# test content-type with something after boundary=xxx
  AFTERBOUND=';micalg=pgp-md5'
  ${ECHO} "text/html" > "${DIR}"/mimereject
  { make_message | ${EZBIN}/ezmlm-reject "${DIR}" 2>&1; } > /dev/null 2>&1 && \
	{ ${ECHO} "err with text after boundary: 0.30 bug fixed in 0.322"
	  prompt "ezmlm-reject.......   "
	  BUG="${BUG} reject_bound"
	}

# restore
  ${RM} "${DIR}"/mimereject
  AFTERBOUND=''

# if entire message is mimeremove type is should be rejected
  ${ECHO} "multipart/mixed" > "${DIR}"/mimeremove
  { make_message | ${EZBIN}/ezmlm-reject "${DIR}"; } > /dev/null 2>&1  && \
	{ ${ECHO} "mimereject failed with dir"; exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject; } > /dev/null || \
	{ ${ECHO} "mimereject without dir"; exit 100; }

# restore
  ${RM} "${DIR}"/mimeremove

# test headerreject
  ${ECHO} "Content-TYPE" > "${DIR}"/headerreject
  { make_message | ${EZBIN}/ezmlm-reject -H "${DIR}"; } > /dev/null || \
	{ ${ECHO} "headerreject -H failed with dir"; exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject -h "${DIR}"; } > /dev/null 2>&1 && \
	{ ${ECHO} "headerreject failed with dir"; exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject; } > /dev/null || \
	{ ${ECHO} "headerreject failed without dir"; exit 100; }
  { make_message | ${EZBIN}/ezmlm-reject -h; }  > /dev/null 2>&1  && \
	{ ${ECHO} "-h was accepted without dir"; exit 100; }

# Suppress content-type header
  CONTENT=''
  { make_message | ${EZBIN}/ezmlm-reject "${DIR}"; } > /dev/null || \
	{ ${ECHO} "headerreject rejected even though header isn't there"; \
	exit 100; }

  CONTENT='multIpart/mIXed'

  ${ECHO} "OK"
###############################
# ezmlm-sub/unsub/list/issubn #
###############################

  prompt "ezmlm-[un|is]sub[n]:  "

  SENDER="XYZZY@HOst"; export SENDER

# With mysql testing, there may be junk left from earlier testing that
# gives false positives in testing. Make sure it's detected
  ${EZBIN}/ezmlm-list "${DIR}" >/dev/null || \
	{ ${ECHO} "ezmlm-list: failed"; exit 100; }

  ${EZBIN}/ezmlm-list "${DIR}" | ${GREP} '@' >/dev/null 2>&1 && \
	{ ${ECHO} "already addresses in table - please remove and start again";
		exit 100; }

  ${EZBIN}/ezmlm-list "${DIR}/digest" | ${GREP} '@' >/dev/null 2>&1 && \
	{ ${ECHO} "already addresses in table - please remove and start again";
		exit 100; }

  ${EZBIN}/ezmlm-list "${DIR}/${ALLOW}" | ${GREP} '@' >/dev/null 2>&1 && \
	{ ${ECHO} "already addresses in table - please remove and start again";
		exit 100; }

# not subscriber. Test default
  ${EZBIN}/ezmlm-issubn "${DIR}" "${DIR}/${ALLOW}" && \
	{ ${ECHO} "ezmlm-issubn: failed: exit 0 on non-subscriber"; exit 100; }

# not subscriber. Test -n
  ${EZBIN}/ezmlm-issubn -n "${DIR}" "${DIR}/${ALLOW}" || \
	{ ${ECHO} "ezmlm-issubn: -n failed for non-subscriber"; exit 100; }

# add subscriber
  ${EZBIN}/ezmlm-sub "${DIR}" "xyZZy@hoSt" || \
	{ ${ECHO} "ezmlm-sub: failed to add subscriber"; exit 100; }

# is subscriber. Test default
  ${EZBIN}/ezmlm-issubn "${DIR}" "${DIR}/${ALLOW}" || \
	{ ${ECHO} "ezmlm-issubn: failed: exit false for subscriber"; exit 100; }

# is subscriber. Test -n
  ${EZBIN}/ezmlm-issubn -n "${DIR}" "${DIR}/${ALLOW}" && \
	{ ${ECHO} "ezmlm-issubn: -n failed for subscriber"; exit 100; }

# add to allow
  ${EZBIN}/ezmlm-sub "${DIR}/${ALLOW}" "ZZtop@hoSt" || \
	{ ${ECHO} "ezmlm-sub: failed to add address to ${DIR}/${ALLOW}"; exit 100; }

# list subscribers
  ${EZBIN}/ezmlm-list "${DIR}" | ${GREP} "xyZZy" >"${ERR}" 2>&1 || \
	{ ${ECHO} "ezmlm-list: failed to list subscribers"; exit 100; }

# remove subscriber
  ${EZBIN}/ezmlm-unsub "${DIR}" "xYzZy@hOst" || \
	{ ${ECHO} "ezmlm-sub: failed to add subscriber"; exit 100; }

# see that it was removed
  ${EZBIN}/ezmlm-list "${DIR}" | ${GREP} "xyZZy" >"${ERR}" 2>&1 && \
	{ ${ECHO} "ezmlm-unsub: failed to remove subscriber"; exit 100; }

  SENDER="zztop@HOst"; export SENDER

# check for address in allow
  ${EZBIN}/ezmlm-issubn "${DIR}" "${DIR}/${ALLOW}" || \
	{ ${ECHO} "ezmlm-sub/issubn: failed to add/look in 2nd db"; exit 100; }

# remove (multiple) (non)existing addresses from allow
  ${EZBIN}/ezmlm-unsub "${DIR}/${ALLOW}" "xYzZy@hOst" "zZToP@HOSt" || \
	{ ${ECHO} "ezmlm-unsub: failed to remove subscriber"; exit 100; }

# verify removal
  ${EZBIN}/ezmlm-issubn "${DIR}" "${DIR}/${ALLOW}" && \
	{ ${ECHO} "ezmlm-unsub/issubn: failed to remove address"; exit 100; }

# clean up
  LOCAL=''; export LOCAL

  ${ECHO} "OK"
##############
# ezmlm-send #
##############
  prompt "ezmlm-send (1/2):     "

  SENDER="${SND}@$HOST"; export SENDER
  ${EZBIN}/ezmlm-sub "${DIR}" "$SENDER"
# set up prefix
  ${ECHO} "[PFX]" > "${DIR}/prefix"
# set up trailer
  { ${ECHO} "--- TRAILER ---"; ${ECHO}; } > "${DIR}/text/trailer"
# test
  { ${ECHO} "X-num: msg1"; make_message; } | \
	${EZBIN}/ezmlm-send "${DIR}" >"${ERR}" 2>&1 || \
	{ ${ECHO} "failed to accept normal message"; exit 100; }
  if [ `cat "${DIR}/num"` != "1:1" ]; then
	${ECHO} "failed to create num for normal message 1"; exit 100; 
  fi
  if [ ! -x "${DIR}/archive/0/01" ]; then
	{ ${ECHO} "failed to archive normal message"; exit 100; }
  fi
  ${GREP} "1:" "${DIR}/archive/0/index" >/dev/null 2>&1 || \
	{ ${ECHO} "failed to index archive"; exit 100; }

  ${RM} -f "${DIR}/indexed"
  ${RM} -f "${DIR}/archived"

# test to see that trailer is added to nom-mime messages
  CONTENT=''
  { ${ECHO} "X-num: msg5"; make_message; } | \
	${EZBIN}/ezmlm-send "${DIR}" >"${ERR}" 2>&1  || \
	{ ${ECHO} "failed to accept non-mime message"; exit 100; }

# test to see that trailer is suppressed for multipart/signed
  CONTENT='multipart/signed'
  { ${ECHO} "X-num: msg6"; make_message; } | \
	${EZBIN}/ezmlm-send "${DIR}" >"${ERR}" 2>&1  || \
	{ ${ECHO} "failed to accept multipart/signed message"; exit 100; }

# restore
  CONTENT='multipart/mixed'

# test content-type with something after boundary=xxx
  AFTERBOUND=';micalg=pgp-md5'
  ${ECHO} "text/html" > "${DIR}"/mimeremove
  make_message | ${EZBIN}/ezmlm-send "${DIR}" >"${ERR}" 2>&1  || \
	{ ${ECHO} "err with text after boundary: 0.30 bug fixed in 0.322"
	  prompt "ezmlm-send.........   "
	  BUG="${BUG} send_bound"
	}
# restore
  AFTERBOUND=''
  ${ECHO} "1:1" > "${DIR}/num"
  ${RM} "${DIR}"/mimeremove

# -r => don't trim received headers
  { ${ECHO} "X-num: msg2"; make_message; } | \
	${EZBIN}/ezmlm-send -r "${DIR}" >"${ERR}" 2>&1 || \
	{ ${ECHO} "failed to accept normal message 2"; exit 100; }

  ${GREP} "2:" "${DIR}/archive/0/index" >/dev/null 2>&1 && \
	{ ${ECHO} "indexed message with DIR/indexed missing"; exit 100; }
  ${GREP} "msg2" ${DIR}/archive/0/* >/dev/null 2>&1 && \
	{ ${ECHO} "archived message with DIR/archived missing"; exit 100; }

# -C eliminate SENDER from addressees
  { ${ECHO} "X-num: msg3"; make_message; } | \
	${EZBIN}/ezmlm-send -C "${DIR}" >"${ERR}" 2>&1 || \
	{ ${ECHO} "failed to accept normal message 3"; exit 100; }
  ${EZBIN}/ezmlm-unsub "${DIR}" "$SENDER"

# make sure headerremove was done
  ${GREP} -i 'return-receipt-to' < "${DIR}/archive/0/01" >/dev/null &&
	{ ${ECHO} "failed to remove headerremove"; exit 100; }
# test mimeremove
  touch "${DIR}/archived" "${DIR}/indexed"
  ${ECHO} "teXT/hTml" > "${DIR}/mimeremove"
  { ${ECHO} "X-num: msg4"; make_message; } | \
	${EZBIN}/ezmlm-send "${DIR}" >"${ERR}" 2>&1 || \
	{ ${ECHO} "failed to accept mimeremove message"; exit 100; }
  ${GREP} -i 'text/html' < "${DIR}/archive/0/04" >/dev/null &&
	{ ${ECHO} "failed to remove mimeremove part"; exit 100; }

  ${ECHO} "OK"
################
# ezmlm-tstdig #
################
  prompt "ezmlm-tstdig:         "

  ${EZBIN}/ezmlm-tstdig -k2 -m5 -t1 "${DIR}" || \
	{ ${ECHO} "-t1 failed"; exit 100; }
  ${EZBIN}/ezmlm-tstdig -k2 -m5 -t0 "${DIR}" && \
	{ ${ECHO} "-t0 failed"; exit 100; }

  LOCAL="$LOC-xx"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT='xx'; export DEFAULT
  fi
  ${EZBIN}/ezmlm-tstdig -k2 -m5 -t0 "${DIR}" || \
	{ ${ECHO} "problem with -xx in manager position"; exit 100; }
  LOCAL="$LOC-dig."; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT='dig.'; export DEFAULT
  fi
  ${EZBIN}/ezmlm-tstdig -k2 -m5 -t0 "${DIR}" && \
	{ ${ECHO} "problem with -dig in manager position"; exit 100; }
  LOCAL="$LOC-digest-"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT='digest-'; export DEFAULT
  fi
  ${EZBIN}/ezmlm-tstdig -k2 -m5 -t0 "${DIR}" || \
	{ ${ECHO} "err with -digest- in mgr pos: 0.31 bug fixed in 0.321"
	  prompt "ezmlm-tstdig.......   "
	  BUG="${BUG} digest"
	}
  LOCAL=''; export LOCAL
  if [ "$QMVER" = "n" ]; then
	unset DEFAULT
  fi
  ${EZBIN}/ezmlm-tstdig -k2 -m4 -t1 "${DIR}" || \
	{ ${ECHO} "-m failed"; exit 100; }
  ${EZBIN}/ezmlm-tstdig -k1 -m5 -t0 "${DIR}" || \
	{ ${ECHO} "-k failed"; exit 100; }
  LOCAL="$LOC"; export LOCAL
  ${EZBIN}/ezmlm-tstdig -k1 -m5 -t0 "${DIR}" > "${ERR}" 2>&1 || \
	{
	 ${ECHO} "problem with DEFAULT unset: 0.32 bug, OK in 0.321."
	 prompt "ezmlm-tstdig.......   "
	  BUG="${BUG} tstdig"
	}
  ${ECHO} "OK"

##############
# ezmlm-weed #
##############

  prompt "ezmlm-weed:           "

  ${ECHO} "Subject: test" | ${EZBIN}/ezmlm-weed || \
	{ ${ECHO} "failed to accept good message"; exit 100; }
  ${ECHO} "Subject: success notice" | ${EZBIN}/ezmlm-weed >/dev/null 2>&1 && \
	{ ${ECHO} "failed to reject bad message"; exit 100; }

  ${ECHO} "OK"

##############
# ezmlm-make #
##############
  prompt "ezmlm-make (2/2):     "

# make sure a few ezmlm-make switches work
  ${EZBIN}/ezmlm-make -+qkgu -C${EZBIN}/ezmlmrc "${DIR}" || \
	{ ${ECHO} "failed to edit test list to +qkgu"; exit 100; }
  ${GREP} "${DENY}" "${DIR}/editor" >/dev/null 2>&1 || \
	{ ${ECHO} "failed to implement -k for list"; exit 100; }
  ${GREP} "ezmlm-request" "${DIR}/manager" >/dev/null 2>&1 || \
	{ ${ECHO} "failed to implement -q for list"; exit 100; }
  ${GREP} "ezmlm-get -s" "${DIR}/manager" >/dev/null 2>&1 || \
	{ ${ECHO} "failed to implement -g for list"; exit 100; }
  ${GREP} "${ALLOW}" "${DIR}/editor" >/dev/null 2>&1 || \
	{ ${ECHO} "failed to implement -u for list"; exit 100; }

  ${EZBIN}/ezmlm-make -+QKGU -C${EZBIN}/ezmlmrc "${DIR}" || \
	{ ${ECHO} "failed to edit test list to +QKGU"; exit 100; }
  ${GREP} "${DENY}" "${DIR}/editor" >/dev/null 2>&1 && \
	{ ${ECHO} "failed to implement -K for list"; exit 100; }
  ${GREP} "ezmlm-request" "${DIR}/manager" >/dev/null 2>&1 && \
	{ ${ECHO} "failed to implement -Q for list"; exit 100; }
  ${GREP} "ezmlm-get -s" "${DIR}/manager" >/dev/null 2>&1 && \
	{ ${ECHO} "failed to implement -G for list"; exit 100; }
  ${GREP} "${ALLOW}" "${DIR}/editor" >/dev/null 2>&1 && \
	{ ${ECHO} "failed to implement -U for list"; exit 100; }

# edit the list (add moderation and remove admin)
  ${EZBIN}/ezmlm-make -+rsm -C${EZBIN}/ezmlmrc "${DIR}" || \
	{ ${ECHO} "failed to edit test list to +rsm"; exit 100; }
# edit the list (add text file editing and list/log)
${EZBIN}/ezmlm-make -+ln -C${EZBIN}/ezmlmrc "${DIR}" || \
	{ ${ECHO} "failed to edit test list to +ln"; exit 100; }

# Now to create our own manager for later tests:

${ECHO} "|${GREP} 'req1' >/dev/null 2>&1 && { ${ECHO} \"\$LOCAL\" >> '${REQ}'; exit 99; }; exit 0" > "${DIR}/manager"
${ECHO} "|${EZBIN}/ezmlm-manage -le ${SW_FROM} '${DIR}'" >> "${DIR}/manager"
${ECHO} "OK"

# correct bouncer for our binaries:
###################################
  ${ECHO} "|/${EZBIN}/ezmlm-weed" > "${DIR}/bouncer"
  ${ECHO} "|/${EZBIN}/ezmlm-weed" > "${DIR}/digest/bouncer"
  if [ "$EZVER" = "31" ]; then	# autodetecting bouncer for 0.31x
    ${ECHO} "|/${EZBIN}/ezmlm-return '${DIR}'" >> "${DIR}/bouncer"
    ${ECHO} "|/${EZBIN}/ezmlm-return '${DIR}'" >> "${DIR}/digest/bouncer"
  else				# split bouncer with args for later versions
    ${ECHO} "|/${EZBIN}/ezmlm-return -D '${DIR}'" >> "${DIR}/bouncer"
    ${ECHO} "|/${EZBIN}/ezmlm-return -d '${DIR}'" >> "${DIR}/digest/bouncer"
  fi

# if testing qmail>=1.02, remove inlocal/inhost - shouldn't be used
  if [ "$QMVER" = "n" ]; then
	${RM} -f "${DIR}/inlocal" "${DIR}/inhost" > /dev/null || \
	  { ${ECHO} "failed to remove inlocal/inhost for testlist"; exit 100; }
  fi


###############
# ezmlm-clean #
###############

  prompt "ezmlm-clean (1/2):    "

# clean1 should be silently removed (no -x).
# clean2 should result in a message
# clean3 should not since it's time hasn't come
# clean4 should be removed, but not result in a message since we use -R

  ${ECHO} "Return-Path: <${DIG}@$HOST>" > "${DIR}/mod/pending/1"
  ${ECHO} "X-num: clean1" >> "${DIR}/mod/pending/1"
  ${ECHO} "Return-Path: <${DIG}@${HOST}>" > "${DIR}/mod/pending/2"
  ${ECHO} "X-num: clean2" >> "${DIR}/mod/pending/2"
  ${ECHO} "Return-Path: <${DIG}@$HOST>" > "${DIR}/mod/pending/1999999999"
  ${ECHO} "X-num: clean3" >> "${DIR}/mod/pending/1999999999"

  chmod +x "${DIR}/mod/pending/2" "${DIR}/mod/pending/1999999999"

  ${EZBIN}/ezmlm-clean "${DIR}" >"${ERR}" 2>&1 ||
	{ ${ECHO} "failed first invocation"; exit 100; }
  if [ -r "${DIR}/mod/pending/1" ]; then
	${ECHO} "failed to remove non-x moderation queue entry 1"
	exit 100
  fi
  if [ -r "${DIR}/mod/pending/2" ]; then
	${ECHO} "failed to remove moderation queue entry 2"
	exit 100
  fi
  if [ ! -r "${DIR}/mod/pending/1999999999" ]; then
	${ECHO} "removed mod queue entry 3 that wasn't due"
	exit 100
  fi

${ECHO} <<EOF > "${DIR}/mod/pending/4"
Return-Path: <${DIG}@$HOST>
X-num: clean4
EOF
  chmod +x "${DIR}/mod/pending/4"
  ${EZBIN}/ezmlm-clean -R "${DIR}" >"${ERR}" 2>&1 ||
	{ ${ECHO} "-R failed"; exit 100; }
  if [ -r  "${DIR}/mod/pending/4" ]; then
	${ECHO} "failed to remove moderation queue entry 4"; exit 100
  fi

  ${ECHO} "OK"

###############
# ezmlm-store #
###############

  prompt "ezmlm-store (1/2):    "

  SENDER="${SND}@$HOST"; export SENDER
  ${EZBIN}/ezmlm-sub "${DIR}/mod" "$SENDER"

# message from mod, normal use -> should queue
  { ${ECHO} "X-num: mod1"; make_message; } > ${TMP};
	${EZBIN}/ezmlm-store "${DIR}" >"${ERR}" 2>&1 < ${TMP} || \
	{ ${ECHO} "failed to process message 1"; exit 100; }

  cat ${DIR}/mod/pending/* | ${GREP} "mod1" > /dev/null || \
	{ ${ECHO} "failed to queue message 1"; exit 100; }

  ${RM} -f "${DIR}/modpost" 

# no modpost - should go directly to list
  { ${ECHO} "X-num: mod2"; make_message; } > ${TMP};
	${EZBIN}/ezmlm-store "${DIR}" >"${ERR}" 2>&1 < ${TMP} || \
	{
	  ${GREP} -v "child" "${ERR}" > /dev/null 2>&1
	  if [ "$?" != "0" ]; then
	    ${ECHO} "Failed to process message mod2"; exit 100
	  else
	    EZFORK='no'
	  fi
	}

  cat ${DIR}/mod/pending/* | ${GREP} "mod2" > /dev/null && \
	{ ${ECHO} "queued message 2 despite non-modpost"; exit 100; }

  if [ -z "$EZFORK" ]; then
	cat ${DIR}/archive/0/* | ${GREP} "mod2" > /dev/null || \
		{ ${ECHO} "failed to archive message 2 (non-modpost)"; exit 100; }
  fi

  touch "${DIR}/modpost"

# from moderator. Should be queued, even with -P
  { ${ECHO} "X-num: mod3"; make_message; } > ${TMP};
	${EZBIN}/ezmlm-store -P "${DIR}" >"${ERR}" 2>&1 < ${TMP} || \
	{ ${ECHO} "-P failed to accept mods post 3"; exit 100; }

  cat ${DIR}/mod/pending/* | ${GREP} "mod3" > /dev/null || \
	{ ${ECHO} "failed to queue message 3"; exit 100; }

  ${EZBIN}/ezmlm-unsub "${DIR}/mod" "$SENDER"

# not from moderator, should be rejected directly with -P
  { ${ECHO} "X-num: mod4"; make_message; } > ${TMP};
	${EZBIN}/ezmlm-store -P "${DIR}" >"${ERR}" 2>&1 < ${TMP} && \
	{ ${ECHO} "-P failed to reject non-mod message 4"; exit 100; }

  ${ECHO} "OK"

################
# ezmlm-return #
################
  prompt "ezmlm-return:         "

  SENDER="${BNC}@$HOST"; export SENDER
  HOST="$HOST"; export HOST
  LOCAL="$LOC-return-1-$BNC=$HOST"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT="1-$BNC=$HOST"; export DEFAULT
  fi
# we use 'du' because bounce handling is different in 0.31x and >=0.32
  BSIZE1=`${DU} "${DIR}/bounce"` || \
	{ ${ECHO} "du doesn't work"; exit 99; } 
  make_message | ${EZBIN}/ezmlm-return "${DIR}" || \
    [ "$?" -eq "99" ] || \
	{ ${ECHO} "failed to process normal bounce from non-sub" ; exit 100; }
  BSIZE2=`${DU} "${DIR}/bounce"`
  if [ "$BSIZE1" != "$BSIZE2" ]; then
	${ECHO} "failed to ignore non-subscriber bounce" ; exit 100
  fi
  ${EZBIN}/ezmlm-sub "${DIR}" "${BNC}@$HOST"
  make_message | ${EZBIN}/ezmlm-return "${DIR}" || \
    [ "$?" -eq "99" ] || \
	{ ${ECHO} "failed to process normal bounce from sub" ; exit 100; }
  BSIZE1=`${DU} "${DIR}/bounce"`
  if [ "$BSIZE1" = "$BSIZE2" ]; then
	${ECHO} "failed to note subscriber bounce" ; exit 100
  fi
  LOCAL="$LOC-digest-return-1-$BNC=$HOST"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT="1-$BNC=$HOST"; export DEFAULT
  fi
  BSIZE1=`${DU} "${DIR}/digest/bounce"`
  make_message | ${EZBIN}/ezmlm-return $DLC "${DIR}" || \
    [ "$?" -eq "99" ] || \
	{ ${ECHO} "failed to process normal digest non-sub bounce" ; exit 100; }
  BSIZE2=`${DU} "${DIR}/digest/bounce"`
  if [ "$BSIZE1" != "$BSIZE2" ]; then
	${ECHO} "failed to ignore non-digest-subscriber bounce" ; exit 100
  fi
  ${EZBIN}/ezmlm-unsub "${DIR}" "${BNC}@$HOST"
  ${EZBIN}/ezmlm-sub "${DIR}/digest" "${BNC}@$HOST"
  make_message | ${EZBIN}/ezmlm-return $DLC "${DIR}" || \
    [ "$?" -eq "99" ] || \
	{ ${ECHO} "failed to proc. nl digest-subscriber bounce" ; exit 100; }
  BSIZE1=`${DU} "${DIR}/digest/bounce"`
  if [ "$BSIZE1" = "$BSIZE2" ]; then
	${ECHO} "failed to note digest-subscriber bounce" ; exit 100
  fi
  ${EZBIN}/ezmlm-sub "${DIR}" "${BNC}@$HOST"

  ${ECHO} "OK"

# as we exit, the bounce address is subscribed to both list and digest-list
# and is the SENDER

##############
# ezmlm-warn #
##############
  prompt "ezmlm-warn (1/3):     "

# should send a warning
  ${EZBIN}/ezmlm-warn -t0 "${DIR}" >"${ERR}" 2>&1 || \
	{ ${ECHO} "failed with normal bounce for warning"; exit 100; }
  ${EZBIN}/ezmlm-issubn "${DIR}" || \
	{ ${ECHO} "script error: SENDER is not a subscriber"; exit 100; }

  ${EZBIN}/ezmlm-warn -d -t0 "${DIR}" >"${ERR}" 2>&1 || \
	{ ${ECHO} "failed with digest bounce for warning"; exit 100; }
  ${EZBIN}/ezmlm-issubn "${DIR}/digest" || \
	{ ${ECHO} "script error: SENDER is not a digest subscriber"; exit 100; }

  ${ECHO} "OK"

################
# ezmlm-manage #
################
  prompt "ezmlm-manage (1/4):   "

  LOCAL="$LOC-unsubscribe"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT='unsubscribe'; export DEFAULT
  fi
  SENDER="${SND}@$HOST"; export SENDER

  ${EZBIN}/ezmlm-sub "${DIR}" "${SND}@$HOST"
  ${EZBIN}/ezmlm-manage -U "${DIR}" </dev/null >"${ERR}" 2>&1 || \
	{ ${ECHO} "failed with -U"; exit 100; }
  ${EZBIN}/ezmlm-issubn "${DIR}" && \
	{ ${ECHO} "unsubscribe with -U failed"; exit 100; }

  LOCAL="$LOC-digest-subscribe"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT='digest-subscribe'; export DEFAULT
  fi
  ${EZBIN}/ezmlm-unsub "${DIR}/digest" "${SND}@$HOST"

# test that access to the deny db is restricted to remote admins
  LOCAL="$LOC-deny-subscribe"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT='deny-subscribe'; export DEFAULT
  fi
  ${EZBIN}/ezmlm-manage "${DIR}" </dev/null >/dev/null 2>&1 && \
	{
	 ${ECHO} "Deny open to regular subscribers: 0.31 bug, OK in 0.321."
	 prompt "ezmlm-manage ...      "
	 BUG="${BUG} deny"
	}
  SENDER="${MOD}@$HOST"; export SENDER
  ${EZBIN}/ezmlm-sub "${DIR}/mod" "$SENDER" || exit 100
  ${EZBIN}/ezmlm-manage "${DIR}" </dev/null > "${ERR}" 2>&1 || \
	{ ${ECHO} "Deny access denied to remote admin!"; exit 100; }

# make non-moderated
  ${RM} -f "${DIR}/modsub" || \
	{ ${ECHO} "Failed to remove DIR/modsub"; exit 99; }

# make non-remote
  ${RM} -f "${DIR}/remote" || \
	{ ${ECHO} "Failed to remove DIR/remote"; exit 99; }
  ${EZBIN}/ezmlm-manage "${DIR}" </dev/null > "${ERR}" 2>&1 && \
	{
	 ${ECHO} "Deny even without remote/modsub: 0.31 bug, OK in 0.321."
	 prompt "ezmlm-manage ...      "
	 BUG="${BUG} deny"
	}

# restore remote/SENDER/mod/LOCAL/DEFAULT
  ${EZBIN}/ezmlm-unsub "${DIR}/mod" "$SENDER" || exit 100
  SENDER="${SND}@$HOST"; export SENDER	# restore order
  touch "${DIR}/remote" || \
	{ ${ECHO} "Failed to remove DIR/remote"; exit 99; }
  LOCAL="$LOC-digest-subscribe"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT='digest-subscribe'; export DEFAULT
  fi

  ${EZBIN}/ezmlm-manage -S "${DIR}" </dev/null >"${ERR}" 2>&1 || \
	{ ${ECHO} "failed with -S"; exit 100; }
  ${EZBIN}/ezmlm-issubn "${DIR}/digest" || \
	{ ${ECHO} "digest-subscribe with -S failed"; exit 100; }
  ${EZBIN}/ezmlm-unsub "${DIR}/digest" "${SND}@$HOST"
  touch "${DIR}/modsub" || \
	{ ${ECHO} "Failed to restore DIR/modsub"; exit 99; }

  SENDER="${MAN}@$HOST"; export SENDER

  ${ECHO} "X-num: sub1" > "${DIR}/__tmp"
  ${ECHO} "From: Mr. $EZTEST requests <${MAN}@$HOST>" >> "${DIR}/__tmp"
  ${ECHO} >> "${DIR}/__tmp"
  ${EZBIN}/ezmlm-manage ${SW_FROM} "${DIR}" < "${DIR}/__tmp" \
		>"${ERR}" 2>&1 || \
	{ ${ECHO} "digest-subscribe with request failed"; exit 100; }

  ${EZBIN}/ezmlm-sub "${DIR}" "${MAN}@$HOST"
  LOCAL="$LOC-unsubscribe"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT='unsubscribe'; export DEFAULT
  fi
  ${ECHO} "X-num: sub2" > "${DIR}/__tmp"
  ${EZBIN}/ezmlm-manage "${DIR}" < "${DIR}/__tmp" >"${ERR}" 2>&1 || \
	{ ${ECHO} "unsubscribe request failed"; exit 100; }

# -get function for backwards compatibility
  LOCAL="$LOC-get.1"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT='get.1'; export DEFAULT
  fi
  ${ECHO} "X-num: manget1" > "${DIR}/__tmp"
  ${EZBIN}/ezmlm-manage "${DIR}" < "${DIR}/__tmp" >"${ERR}" 2>&1 || \
	{ ${ECHO} "get failed"; exit 100; }
# -C should disable it
  ${EZBIN}/ezmlm-manage -C "${DIR}" < "${DIR}/__tmp" >"${ERR}" 2>&1 && \
	{ ${ECHO} "-C failed to disable -get"; exit 100; }

  ${ECHO} "OK"

#################
# ezmlm-request #
#################
  prompt "ezmlm-request (1/2):  "

  SENDER="${SND}@$HOST"; export SENDER
  LOCAL="$LOC-request"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT='request'; export DEFAULT
  fi

  ${ECHO} "X-num: req1" > "${DIR}/__tmp"
# use a non-existing command
  ${ECHO} "Subject: qqqq ${SND}@$HOST" >> "${DIR}/__tmp"
  ${EZBIN}/ezmlm-request "${DIR}" < "${DIR}/__tmp" > "${ERR}" 2>&1
  if [ "$?" != "99" ]; then
	${ECHO} "qqqq command in subject failed to exit 99"
	exit 100
  fi

  ${ECHO} "X-num: req1" > "${DIR}/__tmp"
# test full ezmlm cmd in subject and command substitution
  ${ECHO} "Subject: ${LOC}-remove-${SND}=${HOST}@${HOST}" >> "${DIR}/__tmp"
  ${EZBIN}/ezmlm-request "${DIR}" < "${DIR}/__tmp" > "${ERR}" 2>&1
  if [ "$?" != "99" ]; then
	${ECHO} "full ezmlm command in subject failed to exit 99"
	exit 100
  fi



  ${ECHO} "OK"

###############
# ezmlm-split #
###############
if [ "$QMVER" = "n" ]; then
  prompt "ezmlm-split (1/2):    "
# set up split file
  ${ECHO} "edu:1:26:l1@h1" > "${DIR}/split"
  ${ECHO} "edu:27:52:l2@h2" >> "${DIR}/split"
  ${ECHO} "com:::l3@h3" >> "${DIR}/split"
# most testing with -D
  ${ECHO} "lindberg@ezmlm.org" | ${EZBIN}/ezmlm-split -D "${DIR}" | \
	${GREP} "$LIST@$HOST" >/dev/null || \
	{ ${ECHO} "failed to split correctly on domain"; exit 100; }
  ${ECHO} "lindberg@id.com" | ${EZBIN}/ezmlm-split -D "${DIR}" | \
	${GREP} 'l3' >/dev/null || \
	{ ${ECHO} "failed to split correctly on domain"; exit 100; }
  ${ECHO} "lindberg@id.wustl.edu" | ${EZBIN}/ezmlm-split -D "${DIR}" | \
	${GREP} 'l1' >/dev/null || \
	{ ${ECHO} "failed to split correctly on hash + domain"; exit 100; }
  ${ECHO} "cfl@id.wustl.edu" | ${EZBIN}/ezmlm-split -D "${DIR}" | \
	${GREP} 'l2' >/dev/null || \
	{ ${ECHO} "failed to split correctly on hash + domain"; exit 100; }
# one test with delivery - redirect to local manager
# should exit 99 after redirecting
  ${ECHO} ":::${LOC}@$HOST" > "${DIR}/split"
  SENDER="${MOD}@$HOST"; export SENDER
  DTLINE="Delivered-To: ezmlm-split@$HOST"; export DTLINE
  LOCAL="$LOC-subscribe-${SND}=$HOST"; export LOCAL
  if [ "$QMVER" = "n" ]; then
	DEFAULT="subscribe-${SND}=$HOST"; export DEFAULT
  fi
  ${ECHO} "X-num: spl1" | ${EZBIN}/ezmlm-split "${DIR}" >"${ERR}" 2>&1

  EC="$?"
  if [ "$EC" -eq "0" ]; then
	${ECHO} "exited 0 after forwarding, rather than 99"; exit 100
  elif [ "$EC" != "99" ]; then
	${ECHO} "failed to process message for forwarding"; exit 100
  fi
# if no match, should exit 0
  ${ECHO} "___:::${LOC}@$HOST" > "${DIR}/split"
  ${ECHO} "X-num: spl1" | ${EZBIN}/ezmlm-split "${DIR}" >"${ERR}" 2>&1 || \
	{ ${ECHO} "failed to exit 0 after failing to match"; exit 100; }

  ${ECHO} "OK"
fi

########################
# waiting for delivery #
########################
  send_test 2
fi		# end of sect 1
